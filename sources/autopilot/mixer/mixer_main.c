// mixer_loop.c


#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

#include "mixer_main.h"
#include "../../uav_type.h"

#include "../../uav_library/common.h"
#include "../../uav_library/param/param.h"
#include "../../uav_library/time/drv_time.h"
#include "../../uav_library/io_ctrl/comunicator.h"
#include "../../uav_library/io_ctrl/socket_io.h"

#include "../../ORB/ORB.h"
#include "../../ORB/topics/parameter_update.h"
#include "../../ORB/topics/actuator/actuator_armed.h"
#include "../../ORB/topics/actuator/actuator_controls.h"
#include "../../ORB/topics/actuator/actuator_outputs.h"
#include "../../ORB/topics/actuator/actuator_effective_controls.h"
#include "../../ORB/topics/position/vehicle_global_position.h"



//#define OVERWRITE_CONTROLS_BEFORE_TAKEOFF

bool_t hil_enabled;
fixedwing_mixer_t fixedwing_mixer;
multirotor_mixer_t multirotor_mixer;



/*
 * These tables automatically generated by multi_tables - do not edit.
 */
const rotor_scale _config_quad_x[] = {
	{ -0.707107,  0.707107,  1.00 },
	{  0.707107, -0.707107,  1.00 },
	{  0.707107,  0.707107, -1.00 },
	{ -0.707107, -0.707107, -1.00 },
};
const rotor_scale _config_quad_plus[] = {
	{  0.000000,  1.000000, -1.00 },
	{ -0.000000, -1.000000, -1.00 },
	{ -1.000000,  0.000000,  1.00 },
	{  1.000000,  0.000000,  1.00 },
};
const rotor_scale _config_quad_v[] = {
	{ -0.927184,  0.374607,  1.00 },
	{  0.694658, -0.719340,  1.00 },
	{  0.927184,  0.374607, -1.00 },
	{ -0.694658, -0.719340, -1.00 },
};
const rotor_scale _config_quad_wide[] = {
	{ -0.927184,  0.374607,  1.00 },
	{  0.777146, -0.629320,  1.00 },
	{  0.927184,  0.374607, -1.00 },
	{ -0.777146, -0.629320, -1.00 },
};
const rotor_scale _config_hex_x[] = {
	{ -1.000000,  0.000000, -1.00 },
	{  1.000000,  0.000000,  1.00 },
	{  0.500000,  0.866025, -1.00 },
	{ -0.500000, -0.866025,  1.00 },
	{ -0.500000,  0.866025,  1.00 },
	{  0.500000, -0.866025, -1.00 },
};
const rotor_scale _config_hex_plus[] = {
	{  0.000000,  1.000000, -1.00 },
	{ -0.000000, -1.000000,  1.00 },
	{  0.866025, -0.500000, -1.00 },
	{ -0.866025,  0.500000,  1.00 },
	{  0.866025,  0.500000,  1.00 },
	{ -0.866025, -0.500000, -1.00 },
};
const rotor_scale _config_octa_x[] = {
	{ -0.382683,  0.923880, -1.00 },
	{  0.382683, -0.923880, -1.00 },
	{ -0.923880,  0.382683,  1.00 },
	{ -0.382683, -0.923880,  1.00 },
	{  0.382683,  0.923880,  1.00 },
	{  0.923880, -0.382683,  1.00 },
	{  0.923880,  0.382683, -1.00 },
	{ -0.923880, -0.382683, -1.00 },
};
const rotor_scale _config_octa_plus[] = {
	{  0.000000,  1.000000, -1.00 },
	{ -0.000000, -1.000000, -1.00 },
	{ -0.707107,  0.707107,  1.00 },
	{ -0.707107, -0.707107,  1.00 },
	{  0.707107,  0.707107,  1.00 },
	{  0.707107, -0.707107,  1.00 },
	{  1.000000,  0.000000, -1.00 },
	{ -1.000000,  0.000000, -1.00 },
};
const rotor_scale _config_octa_cox[] = {
	{ -0.707107,  0.707107,  1.00 },
	{  0.707107,  0.707107, -1.00 },
	{  0.707107, -0.707107,  1.00 },
	{ -0.707107, -0.707107, -1.00 },
	{  0.707107,  0.707107,  1.00 },
	{ -0.707107,  0.707107, -1.00 },
	{ -0.707107, -0.707107,  1.00 },
	{  0.707107, -0.707107, -1.00 },
};

const rotor_scale *_config_index[MAX_GEOMETRY] = {
	&_config_quad_x[0],
	&_config_quad_plus[0],
	&_config_quad_v[0],
	&_config_quad_wide[0],
	&_config_hex_x[0],
	&_config_hex_plus[0],
	&_config_octa_x[0],
	&_config_octa_plus[0],
	&_config_octa_cox[0],
};

const unsigned _config_rotor_count[MAX_GEOMETRY] = {
	4, /* quad_x */
	4, /* quad_plus */
	4, /* quad_v */
	4, /* quad_wide */
	6, /* hex_x */
	6, /* hex_plus */
	8, /* octa_x */
	8, /* octa_plus */
	8, /* octa_cox */
};



int fixedwing_mixer_init_component (int input, float negative_scale, float positive_scale, float offset)
{
	/*
	 * Always pull from group 0, with the input value giving the channel.
	 */
	fixedwing_mixer.controls[input].control_group = 0;
	fixedwing_mixer.controls[input].control_index = input;

	/*
	 * Conversion uses both the input and output side of the mixer.
	 *
	 * The input side is used to slide the control value such that the min argument
	 * results in a value of zero.
	 *
	 * The output side is used to apply the scaling for the min/max values so that
	 * the resulting output is a -1.0 ... 1.0 value for the min...max range.
	 */
	fixedwing_mixer.controls[input].scaler.negative_scale = negative_scale;
	fixedwing_mixer.controls[input].scaler.positive_scale = positive_scale;
	fixedwing_mixer.controls[input].scaler.offset = offset;
	fixedwing_mixer.controls[input].scaler.min_output = -1.0f;
	fixedwing_mixer.controls[input].scaler.max_output = 1.0f;

	return 0;
}


int fixedwing_mixer_init ()
{
	fixedwing_mixer.control_count = 4;

	fixedwing_mixer_init_component (0 /* aileron */, 1.0f, 1.0f, 0.0f);
	fixedwing_mixer_init_component (1 /* elevator */, -1.0f, -1.0f, 0.0f); // XXX CHECK THIS
	fixedwing_mixer_init_component (2 /* rudder */, 1.0f, 1.0f, 0.0f);
	fixedwing_mixer_init_component (3 /* throttle */, 0.0f, 1.0f, 0.0f);

	return 0;
}


int multirotor_mixer_init (rotor_geometry geometry)
{
	multirotor_mixer.roll_scale = 1.0f;
	multirotor_mixer.pitch_scale = 1.0f;
	multirotor_mixer.yaw_scale = 1.0f;
	multirotor_mixer.deadband = 0.0f;	/* shift to output range here to avoid runtime calculation */

	multirotor_mixer.rotor_count = _config_rotor_count[geometry];
	multirotor_mixer.rotors = _config_index[geometry];

	return 0;
}


int fixedwing_mix(float* controls, float *controls_eff, float *outputs)
{
	int i;
	float input, output;

	for (i = 0; i < fixedwing_mixer.control_count; i++)
	{
		input = controls[i];

		if (input < 0.0f) {
			output = (input * fixedwing_mixer.controls[i].scaler.negative_scale) + fixedwing_mixer.controls[i].scaler.offset;

		} else {
			output = (input * fixedwing_mixer.controls[i].scaler.positive_scale) + fixedwing_mixer.controls[i].scaler.offset;
		}

		if (output > fixedwing_mixer.controls[i].scaler.max_output) {
			output = fixedwing_mixer.controls[i].scaler.max_output;

		} else if (output < fixedwing_mixer.controls[i].scaler.min_output) {
			output = fixedwing_mixer.controls[i].scaler.min_output;
		}

		controls_eff[i] = outputs[i] = output;
	}

	return 0;
}

int multirotor_mix(float* controls, float *controls_eff, float *outputs)
{
	int i;
	float roll = controls[0] * multirotor_mixer.roll_scale;
	float pitch = controls[1] * multirotor_mixer.pitch_scale;
	float yaw = controls[2] * multirotor_mixer.yaw_scale;
	float thrust = controls[3];

	float max = 0.0f;
	float fixup_scale;

	/* use an output factor to prevent too strong control signals at low throttle */
	float min_thrust = 0.05f;
	float max_thrust = 1.0f;
	float startpoint_full_control = 0.40f;
	float output_factor;

	/* keep roll, pitch and yaw control to 0 below min thrust */
	if (thrust <= min_thrust) {
		output_factor = 0.0f;
		/* linearly increase the output factor from 0 to 1 between min_thrust and startpoint_full_control */

	} else if (thrust < startpoint_full_control && thrust > min_thrust) {
		output_factor = (thrust / max_thrust) / (startpoint_full_control - min_thrust);
		/* and then stay at full control */

	} else {
		output_factor = max_thrust;
	}

	roll *= output_factor;
	pitch *= output_factor;
	yaw *= output_factor;

	/* perform initial mix pass yielding un-bounded outputs */
	for (i = 0; i < multirotor_mixer.rotor_count; i++) {
		float tmp = roll  * multirotor_mixer.rotors[i].roll_scale +
			    pitch * multirotor_mixer.rotors[i].pitch_scale +
			    yaw   * multirotor_mixer.rotors[i].yaw_scale +
			    thrust;

		if (tmp > max)
			max = tmp;

		outputs[i] = tmp;
	}


	/* scale values into the 0.0 - 2.0 range */
	fixup_scale = (max > 1.0f)? 2.0f / max : 2.0f;
	for (i = 0; i < multirotor_mixer.rotor_count; i++)
		outputs[i] *= fixup_scale;

	controls_eff[0] = roll;
	controls_eff[1] = pitch;
	controls_eff[2] = yaw;
	controls_eff[3] = (outputs[0]/2 + outputs[1]/2 + outputs[2]/2 + outputs[3]/2) / 4.0f;


	/* scale values into the 0.0 - 1.0 range */
	for (i = 0; i < multirotor_mixer.rotor_count; i++)
	{
		if (getenv("DOUBLE_OUTPUT"))
			outputs[i] /= 1.0f;
		else
			outputs[i] /= 2.0f;

	}

	/* ensure outputs are out of the deadband */
	for (i = 0; i < multirotor_mixer.rotor_count; i++)
		if (outputs[i] < multirotor_mixer.deadband)
			outputs[i] = multirotor_mixer.deadband;


	return 0;
}


void* mixer_thread_main (void* args)
{
	/* welcome user */
	fprintf (stdout, "Mixer started\n");
	fflush(stdout);

	int i, updated;
	float takeoff_alt;
	param_t hil_param;
	param_t takeoff_alt_param = PARAM_INVALID;

	/* Advertise topics */
	orb_advert_t pub_actuator_outputs = -1;
	orb_advert_t pub_actuator_eff_controls = -1;
	struct actuator_outputs_s outputs;
	struct actuator_effective_controls_s eff_controls;

	/* Subscribe to topics */
	orb_subscr_t actuator_controls_sub;
	orb_subscr_t armed_sub;
	orb_subscr_t param_sub;
	orb_subscr_t global_pos_sub;
	struct actuator_controls_s actuator_controls;
	struct actuator_armed_s armed;
	struct parameter_update_s p_update;
#ifdef OVERWRITE_CONTROLS_BEFORE_TAKEOFF
	struct vehicle_global_position_s global_pos;
#endif

	memset (&eff_controls, 0, sizeof(eff_controls));
	memset (&outputs, 0, sizeof(outputs));
	outputs.noutputs = 4;


	// ************************************* subscribe and advertise ******************************************
	pub_actuator_outputs = orb_advertise (ORB_ID_VEHICLE_CONTROLS);
	if (pub_actuator_outputs == -1)
	{
		fprintf (stderr, "Mixer thread failed to advertise the actuator_outputs topic\n");
		exit (-1);
	}

	pub_actuator_eff_controls = orb_advertise (ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE);
	if (pub_actuator_eff_controls == -1)
	{
		fprintf (stderr, "Mixer thread failed to advertise the actuator_effective_controls topic\n");
		exit (-1);
	}

	actuator_controls_sub = orb_subscribe (ORB_ID_VEHICLE_ATTITUDE_CONTROLS);
	if (actuator_controls_sub == -1)
	{
		fprintf (stderr, "Mixer thread failed to subscribe the actuator_controls topic\n");
		exit (-1);
	}

	armed_sub = orb_subscribe (ORB_ID(actuator_armed));
	if (armed_sub == -1)
	{
		fprintf (stderr, "Mixer thread failed to subscribe the actuator_armed topic\n");
		exit (-1);
	}

	global_pos_sub = orb_subscribe (ORB_ID(vehicle_global_position));
	if (global_pos_sub == -1)
	{
		fprintf (stderr, "Mixer thread failed to subscribe the vehicle_global_position topic\n");
		exit (-1);
	}

	param_sub = orb_subscribe (ORB_ID(parameter_update));
	if (param_sub == -1)
	{
		fprintf (stderr, "Mixer thread failed to subscribe the parameter_update topic\n");
		exit (-1);
	}
	
	hil_param = param_find("HIL_ENABLED");
	takeoff_alt_param = param_find("TAKEOFF_ALT");
	if (hil_param == PARAM_INVALID || takeoff_alt_param == PARAM_INVALID)
	{
		/* parameter setup went wrong, abort */
		fprintf (stderr, "Mixer thread aborting on startup due to an error\n");
		exit(-1);
	}

	if (is_rotary_wing)
	{
		if (multirotor_mixer_init (r_geometry) < 0)
		{
			fprintf (stderr, "Can't initialize the mixer\n");
			exit(-1);
		}
	}
	else if (fixedwing_mixer_init () < 0)
	{
		fprintf (stderr, "Can't initialize the mixer\n");
		exit(-1);
	}

	

	// **************************************** start mixer loop ******************************************
	while (!_shutdown_all_systems)
	{
		// wait for the result of the autopilot logic calculation
		updated = orb_poll (ORB_ID_VEHICLE_ATTITUDE_CONTROLS, actuator_controls_sub, 50000);
		
		/* timed out - periodic check for _shutdown_all_systems, etc. */
		if (!updated)
			continue;

		if (updated < 0)
		{
			// that's undesiderable but there is not much we can do
			fprintf (stderr, "Mixer thread failed to poll actuator_controls\n");
			continue;
		}
		
		orb_copy (ORB_ID_VEHICLE_ATTITUDE_CONTROLS, actuator_controls_sub, (void *) &actuator_controls);


		/* parameters */
		updated = orb_check (ORB_ID(parameter_update), param_sub);
		if (updated) {
			orb_copy(ORB_ID(parameter_update), param_sub, &p_update);

			/* update parameters */
			param_get (hil_param, &hil_enabled);
			param_get(takeoff_alt_param, &takeoff_alt);
		}

		/* armed */
		if (orb_check(ORB_ID(actuator_armed), armed_sub))
		{
			orb_copy(ORB_ID(actuator_armed), armed_sub, &armed);
		}

#ifdef OVERWRITE_CONTROLS_BEFORE_TAKEOFF
		/* position */
		if (orb_check(ORB_ID(vehicle_global_position), global_pos_sub))
		{
			orb_copy(ORB_ID(vehicle_global_position), global_pos_sub, &global_pos);
		}

		if ((global_pos.altitude - global_pos.ground_level) < takeoff_alt)
		{
			actuator_controls.control[0] = 0.0f;
			actuator_controls.control[2] = 0.0f;
		}
#endif


		if (is_rotary_wing)
			multirotor_mix(actuator_controls.control, eff_controls.control, outputs.output);
		else
			fixedwing_mix(actuator_controls.control, eff_controls.control, outputs.output);


		if (!armed.armed)
		{
			if (is_rotary_wing)
			{
				eff_controls.control[0] = 0.0f;
				eff_controls.control[1] = 0.0f;
				eff_controls.control[2] = 0.0f;
			}
			eff_controls.control[3] = 0.0f;
		}
		orb_publish(ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE, pub_actuator_eff_controls, &eff_controls);


		if (!armed.armed)
		{
			if (is_rotary_wing)
			{
				outputs.output[0] = 0.0f;
				outputs.output[1] = 0.0f;
				outputs.output[2] = 0.0f;
			}
			outputs.output[3] = 0.0f;
		}
		orb_publish(ORB_ID_VEHICLE_CONTROLS, pub_actuator_outputs, &outputs);
	}
	

	/* kill all outputs */
	for (i = 0; i < NUM_ACTUATOR_CONTROLS; i++)
	{
		outputs.output[i] = 0.0f;
		eff_controls.control[i] = 0.0f;
	}

	orb_publish(ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE, pub_actuator_eff_controls, &eff_controls);
	orb_publish(ORB_ID_VEHICLE_CONTROLS, pub_actuator_outputs, &outputs);

	
	/*
	 * do unsubscriptions
	 */
	if (orb_unsubscribe (ORB_ID_VEHICLE_ATTITUDE_CONTROLS, actuator_controls_sub, pthread_self()) < 0)
		fprintf (stderr, "Mixer thread failed to unsubscribe to actuator_controls topic\n");

	if (orb_unsubscribe (ORB_ID(actuator_armed), armed_sub, pthread_self()) < 0)
		fprintf (stderr, "Mixer thread failed to unsubscribe to actuator_controls topic\n");

	if (orb_unsubscribe (ORB_ID(vehicle_global_position), global_pos_sub, pthread_self()) < 0)
		fprintf (stderr, "Mixer thread failed to unsubscribe to vehicle_global_position topic\n");

	if (orb_unsubscribe (ORB_ID(parameter_update), param_sub, pthread_self()) < 0)
		fprintf (stderr, "Mixer thread failed to unsubscribe to actuator_controls topic\n");

	/*
	 * do unadvertises
	 */
	if (orb_unadvertise (ORB_ID_VEHICLE_CONTROLS, pub_actuator_outputs, pthread_self()) < 0)
		fprintf (stderr, "Mixer thread failed to unadvertise the actuator_outputs topic\n");

	if (orb_unadvertise (ORB_ID_VEHICLE_ATTITUDE_CONTROLS_EFFECTIVE, pub_actuator_eff_controls, pthread_self()) < 0)
		fprintf (stderr, "Mixer thread failed to unadvertise the actuator_effective_controls topic\n");

	return 0;
}
